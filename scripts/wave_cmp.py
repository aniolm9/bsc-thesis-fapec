#!/usr/bin/env python3
from matplotlib.ticker import FormatStrFormatter
from scipy.io import wavfile
from pydub import AudioSegment
import matplotlib.pyplot as plt
import matplotlib as mpl
import pandas as pd
import numpy as np
import subprocess
import argparse
import time
import io
import os

def setupParser():
    parser = argparse.ArgumentParser(description='Plot histograms.')
    parser.add_argument('-d', '--directory', type=str, help='Path to the directory of the files in the CSV.')
    parser.add_argument('csv', metavar='CSV', type=str, help='Path to CSV file generated by histograms.py.')
    return parser

def getRatios(file):
    file = os.path.join(args.directory, file)
    extension = os.path.splitext(file)[1]
    # Original file size
    orig_size = os.path.getsize(file)
    # Lossy values
    wave_losses = [1,2,4,6,8,12,16,24,32,48,64,96,128,196,256,384,512]
    lossy = 0
    # Read binary file as int16 samples
    data_array = np.fromfile(file, dtype=np.int16)
    data_array = np.floor_divide(data_array, wave_losses[lossy])
    samplerate = 44100
    if extension == ".iqdata":        
        # Create a Nx2 array for the IQ channels
        in_phase = data_array[::2]
        quadrature = data_array[1::2]
        data_array = np.transpose(np.array([in_phase, quadrature]))
    # Create buffer with WAV samples
    wavBuffer = io.BytesIO()
    wavfile.write(wavBuffer, samplerate, data_array)
    # Compress using FLAC and check ratio
    start = time.time()
    flacBuffer = io.BytesIO()
    song = AudioSegment.from_wav(wavBuffer)
    song.export(flacBuffer, format = "flac")
    end = time.time()
    flac_time = round(end - start, 4)
    ratio_flac = round(orig_size / flacBuffer.getbuffer().nbytes, 3)
    # FAPEC ratio
    start = time.time()
    result = subprocess.check_output('fapec -qq -mt 1 -bl 1024 -chunk 8M -dtype 16 -signed -wave 10 2 0 ' + str(lossy) + ' -per 65536 -trn 65536 -ow -o /dev/stdout ' + '"' + file + '"', shell=True)
    end = time.time()
    fapec_time = round(end - start, 4)
    fapec_size = len(result)
    ratio_fapec = round(orig_size / fapec_size, 3)
    # Gzip ratio
    start = time.time()
    result = subprocess.check_output('gzip -q -c "' + file + '"', shell=True)
    end = time.time()
    gzip_time = round(end - start, 4)
    gzip_size = len(result)
    ratio_gzip = round(orig_size / gzip_size, 3)
    return pd.Series([ratio_fapec, ratio_flac, ratio_gzip, fapec_time, flac_time, gzip_time], index=["ratio_fapec", "ratio_flac", "ratio_gzip", "time_fapec", "time_flac", "time_gzip"])

def plotCompare(df):
    # Use a Sans-Serif for figures
    #fontProperties = {'family': 'sans-serif', 'sans-serif': ['Latin Modern Sans']}
    #mpl.rc('font', **fontProperties)
    fig, ax = plt.subplots(constrained_layout=True)
    fig.suptitle("Comparison of FAPEC, FLAC and GZIP")
    markers = ["x", "o", "v", "^"]
    unicode_markers = [u"✕", u"•", u"▼", u"▲"]
    title = ""
    for i, row in df.iterrows():
        ax.plot(row["time_fapec"], 1/row["ratio_fapec"], "b" + markers[i], label="FAPEC")
        ax.plot(row["time_flac"], 1/row["ratio_flac"], "g" + markers[i], label="FLAC")
        ax.plot(row["time_gzip"], 1/row["ratio_gzip"], "r" + markers[i], label="GZIP")
        title += "File: %s (%s)\n" % (row["file"], unicode_markers[i])
    ax.legend(["FAPEC", "FLAC", "GZIP"])
    ax.grid()
    ax.set_title(title, fontsize=9)
    ax.set_xlabel("Process time [s]")
    ax.set_ylabel("Compression ratio")
    ax.xaxis.set_major_formatter(FormatStrFormatter('%.3f'))
    ax.yaxis.set_major_formatter(FormatStrFormatter('%.3f'))
    # Save figure to vectorial graphics pdf
    plt.savefig(os.path.join(args.directory, args.csv + "_comparison.pdf"))
    plt.close()

if __name__ == "__main__":
    args = setupParser().parse_args()
    df = pd.read_csv(args.csv)
    df = pd.concat([df, df.file.apply(getRatios)], axis=1)
    # Plot diagram and calculate Euclidean distances
    plotCompare(df)
    df["distance_fapec"] = df.apply(lambda row: round(np.linalg.norm([row["time_fapec"], 1/row["ratio_fapec"]]), 4), axis=1)
    df["distance_flac"] = df.apply(lambda row: round(np.linalg.norm([row["time_flac"], 1/row["ratio_flac"]]), 4), axis=1)
    df["distance_gzip"] = df.apply(lambda row: round(np.linalg.norm([row["time_gzip"], 1/row["ratio_gzip"]]), 4), axis=1)
    df.to_csv(args.csv, index=False)
