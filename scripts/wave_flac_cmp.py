#!/usr/bin/env python3
from matplotlib.ticker import FormatStrFormatter
from scipy.io import wavfile
from pydub import AudioSegment
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import subprocess
import argparse
import time
import io
import os

def setupParser():
    parser = argparse.ArgumentParser(description='Plot histograms.')
    parser.add_argument('-d', '--directory', type=str, help='Path to the directory of the files in the CSV.')
    parser.add_argument('csv', metavar='CSV', type=str, help='Path to CSV file generated by histograms.py.')
    return parser

def getFlacRatio(file):
    file = os.path.join(args.directory, file)
    extension = os.path.splitext(file)[1]
    # Original file size
    orig_size = os.path.getsize(file)
    # Read binary file as int16 samples
    data_array = np.fromfile(file, dtype=np.int16)
    lossy = 0
    samplerate = 44100
    if extension == ".iq":
        # Apply lossy
        wave_losses = [1,2,4,6,8,12,16,24,32,48,64,96,128,196,256,384,512]
        lossy = 6
        data_array = np.floor_divide(data_array, wave_losses[lossy])
        # Create a Nx2 array for the IQ channels
        in_phase = data_array[::2]
        quadrature = data_array[1::2]
        data_array = np.transpose(np.array([in_phase, quadrature]))
    # Create buffer with WAV samples
    wavBuffer = io.BytesIO()
    wavfile.write(wavBuffer, samplerate, data_array)
    # Compress using FLAC and check ratio
    start = time.time()
    flacBuffer = io.BytesIO()
    song = AudioSegment.from_wav(wavBuffer)
    song.export(flacBuffer, format = "flac")
    end = time.time()
    flac_time = round(end - start, 4)
    ratio_flac = round(orig_size / flacBuffer.getbuffer().nbytes, 3)
    # FAPEC ratio
    start = time.time()
    result = subprocess.check_output('fapec -qq -mt 1 -bl 1024 -chunk 8M -dtype 16 -signed -wave 10 2 0 ' + str(lossy) + ' -per 65536 -trn 65536 -ow -o /dev/stdout ' + '"' + file + '"', shell=True)
    end = time.time()
    fapec_time = round(end - start, 4)
    fapec_size = len(result)
    ratio_fapec = round(orig_size / fapec_size, 3)
    return pd.Series([ratio_fapec, ratio_flac, fapec_time, flac_time], index=["ratio_fapec", "ratio_flac", "time_fapec", "time_flac"])

def plotCompare(row):
    # Find axis limits
    xmax = 1.1 * max(row["time_fapec"], row["time_flac"])
    xmin = 0.9 * min(row["time_fapec"], row["time_flac"])
    ymax = 1.1 * max(1/row["ratio_fapec"], 1/row["ratio_flac"])
    ymin = 0.9 * min(1/row["ratio_fapec"], 1/row["ratio_flac"])
    fig, ax = plt.subplots()
    fig.suptitle("Comparison of FAPEC and FLAC")
    ax.plot(row["time_fapec"], 1/row["ratio_fapec"], "x", label="FAPEC")
    ax.plot(row["time_flac"], 1/row["ratio_flac"], "x", label="FLAC")
    ax.legend()
    ax.grid()
    ax.set_xlabel("Process time [s]")
    ax.set_ylabel("Compression ratio")
    ax.set_xticks(np.arange(xmin, xmax, step=(xmax-xmin)/10))
    ax.set_yticks(np.arange(ymin, ymax, step=(ymax-ymin)/10))
    ax.xaxis.set_major_formatter(FormatStrFormatter('%.3f'))
    ax.yaxis.set_major_formatter(FormatStrFormatter('%.3f'))
    ax.set_title("File: %s" % (row["file"]), fontsize=9)
    # Save figure to vectorial graphics pdf
    plt.savefig(os.path.join(args.directory, row["file"] + "_comparison.pdf"))
    plt.close()

if __name__ == "__main__":
    args = setupParser().parse_args()
    df = pd.read_csv(args.csv)
    df = pd.concat([df, df.file.apply(getFlacRatio)], axis=1)
    for index, row in df.iterrows():
        plotCompare(row)
        df.at[index, "distance_fapec"] = round(np.linalg.norm([row["time_fapec"], 1/row["ratio_fapec"]]), 4)
        df.at[index, "distance_flac"] = round(np.linalg.norm([row["time_flac"], 1/row["ratio_flac"]]), 4)
    df.to_csv(args.csv, index=False)
