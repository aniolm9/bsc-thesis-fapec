\chapter{Wave Stage}

Earth Observation techniques have been experiencing a growth both in terms of quality and quantity, which means that the amount of data produced have also increased drastically. In addition, remote sensing is usually carried out by satellites with low storage capacity and limited bandwidth \parencite{SANDAU20101}, so clearly data compression is key in this situation.

Some satellites collect \acrshort{rf} data, either from ground or air sources (e.g. vessels, airplanes or industrial activity in general), as well as from other satellites. Between the vast amount of remote sensing techniques we find Radio Occultation \parencite{RO-GNSS}, which uses low orbit satellites to detect the changes produced by the atmosphere in a radio signal emitted by a \acrshort{gnss} satellite. \acrshort{ro} data is mainly used as a weather forecasting tool.

\begin{figure}[h!]
	\begin{center}
		\begin{tabular}{ @{} c @{} }
			\includegraphics[scale=0.44]{images/ro_schematic.jpg}\\
			\imagesource{Wikipedia user MPRennie, CC BY-SA 3.0, via Wikimedia Commons.}
		\end{tabular}
	\end{center}
	\vspace*{-0.7em}
	\caption{Illustration of radio occultation (RO).}
	\label{fig:ro_schematic}
\end{figure}

This chapter is part of a DAPCOM Data Services strategic project focused on developing a new \acrshort{fapec} stage intended to compress data collected by satellites. The algorithm will be tested over \acrshort{iq} sample files and other formats structured in two channels, for instance, stereo audio. The proposed solution will be compared with the well-known \acrshort{flac} coding technique.

\section{Introduction to IQ data}

In the introduction of this chapter we stated that the present stage will be focused on \acrshort{iq} data, that is, the discrete time samples of a \acrshort{rf} \acrshort{iq} signal.

From Communication Theory we know that any pass-band signal $s(t)$ can be expressed as:
\begin{equation}
s(t) = i_s(t) \cdot \cos(2\pi f_0 t) - q_s(t) \cdot \sin(2\pi f_0 t)
\end{equation}

Where:
\begin{description}
	\item $i_s(t) \equiv$ In-phase component of the RF signal.
	\item $q_s(t) \equiv$ Quadrature component of the RF signal.
	\item $f_0 \equiv$ Carrier frequency of the RF signal.
\end{description}

For simplicity, we may work with the equivalent base-band signal $b_s(t)$:
\begin{equation}
	b_s(t) = i_s(t) + j q_s(t)
\end{equation}

Hence, the data to be compressed are the discrete time samples of the signals $i_s(t)$ and $q_s(t)$. In other words, our aim is to compress time series data separated in two channels.

For further information on \acrshort{iq} signals the reader may check references \parencite{IQintro}, \parencite{carlson2010communication} and \parencite{ICOM}.

\section{Motivation and applications of Wave} \label{sec:wave_motivation}
We shall provide a justification on why we can use both \acrshort{iq} and audio files to test Wave and why we can compare it with the \acrshort{flac} standard.

On the first hand, as we will see shortly, both \acrshort{flac} and Wave implement the same preprocessing stage: a classical linear predictor. This decorrelation stage is followed by a Rice-Golomb entropy coder (see section \ref{golomb-coding}) in \acrshort{flac} and by the \acrshort{fapec} entropy coder in Wave.

On the other hand, \acrshort{iq} data and stereo audio have the same structure: time series separated in two channels (notice that samples distribution may not be the same). In fact, most \acrshort{sdr} records are stored as \acrshort{wav} files, a well known audio format.

Additionally, in literature we may find papers about \acrshort{iq} data compression that make use of the \acrshort{flac} algorithm, for instance \parencite{IQFlac}.

To conclude, there are clear similarities between the two proposed algorithms and also between the proposed data formats. Hence, from a qualitative point of view, comparing Wave and \acrshort{flac} with a dataset of \acrshort{iq} data and stereo audio files is a logical choice.

\section{Design}
\begin{comment}
Aquesta etapa decorreladora està enfocada a dades amb 2 canals (àudio stereo, I/Q). El desenvolupament dins de l'empresa està especialment enfocat per un client, però per motius de confidencialitat inclouré una versió genèrica que es podrà comparar amb el FLAC. L'etapa fa servir LPC i posteriorment envia els errors de predicció al codificador entròpic.

L'algoritme és el "típic" per LPC i la resolució del sistema lineal resultant del predictor lineal \parencite{PSAVC} es fa amb Levinson-Durbin \parencite{LevinsonDurbin}, que aprofitant l'estructura Toeplitz redueix la complexitat de $O(n^3)$ a $O(n^2)$.

Disseny del predictor i l'estructura de l'etapa. Justificació de per què s'utilitzen els LPC i no una altra cosa. La resolució de les equacions de Yule-Walker anirà aquí, però segurament en posaré la deducció en un annex.

Subseccions: Requirements, Algorithm design.

En aquesta crec que no cal cap justificació heavy, ja l'he donada a la secció anterior. Segurament posaré el paràgraf que ja hi ha escrit com a inici de la segona subsecció.
\end{comment}

In this section we will design the algorithm intended to decorrelate audio and \acrshort{iq} data. The structure of the section will be the following: first we will state the specific requirements for the stage. Then, according to these and to the data structure described above, an algorithm will be proposed.

\subsection{Requirements and specifications}
Besides the general requirements and specifications for \acrshort{fapec} stages described in section \ref{sec:fapec_reqs}, Wave must also fulfill:
\begin{enumerate}
	\item Compression ratio must be at least an 80\% of \acrshort{flac}'s.
	\item Compression speed must be better than \acrshort{flac}'s.
	\item It shall work for an arbitrary number of channels.
	\item It shall work for 8-bit and 16-bit samples.
\end{enumerate}

\subsection{Algorithm design}
In section \ref{sec:wave_motivation} we justified why \acrshort{flac} should have a good performance with \acrshort{iq} data. Taking this into account, the proposed algorithm should have a structure similar to \acrshort{flac}'s but using \acrshort{fapec} as the entropy coder. This should translate into a compressor faster than \acrshort{flac} and with a similar compression ratio.

From the \acrshort{flac} format specifications we know that its preprocessing stage is based in a linear predictor \parencite{FLAC}. Therefore, our goal is to implement a predictor which, given an input sequence $x(n)$, predicts future samples following the model
\begin{equation}
\hat{x}(n) = \sum_{i=1}^{Q} h_i x(n-i)
\end{equation}
where $\hat{x}(n)$ is the predicted sequence, $x(n-i)$ the previous observed samples, $h_i$ the filter coefficients and $Q$ the filter order.

From filter theory \parencite{PSAVC} we know that the coefficients $h_i$ are given by
\begin{equation} \label{eq_normal_eqs_matrix}
\mathbf{R}_x \mathbf{h} = \mathbf{r}_x
\end{equation}
where $\mathbf{R}_x$ is a $Q \times Q$ Toeplitz matrix with elements $r_{ij} = r_x(|i-j|),\hspace{0.5em} 0 \leq i,j < Q$, $\mathbf{r}_x$ the correlation vector with $r_j = r_x(j),\hspace{0.5em} 0 < j \leq Q$ and $\mathbf{h}$ the filter coefficients.

Equation \ref{eq_normal_eqs_matrix} can also be expressed with scalar notation as:
\begin{equation} \label{eq:normal_equations}
r_x(j) = \sum_{i=1}^{Q} h_i r_x(|i-j|) ,\hspace{0.5em} 0 < j \leq Q
\end{equation}
where $r_x(j)$ is the lag $j$ of the autocorrelation of $x(n)$.

In order to obtain the filter coefficients $h_i$ we need to solve the previous system. In this case, using Gauss-Jordan elimination is not desirable as it has a complexity of $O(n^3)$. However, there exist algorithms such as the Levinson-Durbin recursion (see appendix \ref{ch:l-d}) which, taking advantage of the Toeplitz structure of $\mathbf{R}_x$, reduce the computational complexity to $O(n^2)$.

Now we shall particularize for our case where $x(n)$ is a deterministic finite sequence from an unknown origin. For this reason, we will calculate autocorrelation over intervals of length $N$. Then, $r_x(i)$ is given by:
\begin{equation}
r_x(i) = \sum_{m=0}^{N-1-i} x(m) x(m+i) ,\hspace{0.5em} i \geq 0
\end{equation}

In conclusion, the algorithm 

We should point out that recovering samples in decompression...

\section{Implementation}
\begin{comment}
Això serà una breu explicació més un flowchart. La part del rectify i tal la ignoraré.
\end{comment}

\begin{figure}[h!]
	\begin{center}
		\scalebox{.7}{\input{images/wave_flowchart.tex}}
	\end{center}
	\caption{Flowchart of the Wave preprocessing stage.}
	\label{fig:wave_flowchart}
\end{figure}

\section{Results}
\begin{comment}
He de pensar si faig subseccions o no. La idea és posar els dos tipus d'histogrames, la negentropy i el diagrama de distàncies euclidianes.
\end{comment}
